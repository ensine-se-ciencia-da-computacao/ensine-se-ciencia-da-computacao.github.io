Se voc√™ √© um engenheiro autodidata ou graduado em bootcamp, voc√™ deve aprender ci√™ncia da computa√ß√£o. Felizmente, voc√™ pode se dar uma educa√ß√£o de CS de classe mundial sem investir anos e uma pequena fortuna em um programa de gradua√ß√£o.

H√° muitos recursos dispon√≠veis, mas alguns s√£o melhores que outros. Voc√™ n√£o precisa de mais uma lista ‚Äú200+ cursos on-line gratuitos‚Äù. Voc√™ precisa de respostas para estas perguntas:

- **Quais assuntos** voc√™ deve aprender e por qu√™?
- Qual √© a melhor **s√©rie de livros ou videos** para cada assunto?

Este guia √© nossa tentativa de responder definitivamente a essas perguntas.

## TL; DR:

Estude todos os nove assuntos abaixo, aproximadamente na ordem apresentada, usando o livro ou texto sugerido ou a s√©rie de palestras em v√≠deo, mas √© ideal que estude ambos. Voc√™ deve gastar em torno de 100-200 horas de estudo de cada t√≥pico, e depois basta apenas revisitar os favoritos ao longo de sua carreira üöÄ.

| T√≥pico  | Por que estudar? | Melhor livro | Melhores v√≠deos |
| ------- | ---------------- | ------------ | --------------- |
| Programa√ß√£o | N√£o seja a pessoa que ‚Äúnunca entendeu muito bem‚Äù algo como Recursividade. | Structure and Interpretation of Computer Programs | Berkeley CS 61A, de Brian Harvey |
| Arquitetura de Computadores | Se voc√™ n√£o tiver um modelo mental s√≥lido de como um computador realmente funciona, todas as suas abstra√ß√µes de alto n√≠vel ser√£o fr√°geis. | Computer Organization and Design | Berkeley CS 61C |
| Algoritmos e Estruturas de Dados | Se voc√™ n√£o souber usar estruturas de dados onipresentes como pilhas, filas, √°rvores e gr√°ficos, n√£o conseguir√° resolver problemas dif√≠ceis. | The Algorithm Design Manual	 | Palestras de Steven Skiena |
| Matem√°tica para CS | CS √© basicamente um ramo descontrolado de matem√°tica aplicada, ent√£o aprender matem√°tica lhe dar√° uma vantagem competitiva. | Mathematics for Computer Science | MIT 6.042J de Tom Leighton |
| Sistemas operacionais | A maior parte do c√≥digo que voc√™ escreve √© ‚Äã‚Äãexecutada por um sistema operacional, portanto, voc√™ deve saber como eles interagem. | Operating Systems: Three Easy Pieces | Berkeley CS 162 |
| Redes de Computadores | A Internet acabou sendo um grande neg√≥cio: entender como funciona para liberar todo o seu potencial. | Computer Networking: A Top-Down Approach | Stanford CS 144 |
| Bancos de dados | Os dados est√£o no centro dos programas mais significativos, mas poucos entendem como os sistemas de bancos de dados realmente funcionam. | Readings in Database Systems | Berkeley CS 186 de Joe Hellerstein |
| Idiomas e Compiladores | Se voc√™ entender como linguagens e compiladores realmente funcionam, voc√™ escrever√° um c√≥digo melhor e aprender√° novos idiomas mais facilmente. | Compilers: Principles, Techniques and Tools | Curso de Alex Aiken em Lagunita |
| Sistemas distribu√≠dos | Atualmente, a maioria dos sistemas √© distribu√≠da. | Distributed Systems, 3rd Edition by Maarten van Steen	 | ü§∑‚Äç |


## Por que aprender ci√™ncia da computa√ß√£o?

Existem 2 tipos de engenheiros de software: aqueles que entendem bem a ci√™ncia da computa√ß√£o para fazer um trabalho desafiador e inovador, e aqueles que apenas se d√£o bem porque est√£o familiarizados com algumas ferramentas de alto n√≠vel.

Ambos se chamam engenheiros de software e ambos tendem a ganhar sal√°rios semelhantes em suas primeiras carreiras. Mas os engenheiros do Tipo 1 crescem para um trabalho mais satisfat√≥rio e bem remunerado ao longo do tempo, seja um trabalho comercial valioso ou projetos inovadores de c√≥digo aberto, lideran√ßa t√©cnica ou contribui√ß√µes individuais de alta qualidade.

Engenheiros do tipo 1 encontram maneiras de aprender ci√™ncia da computa√ß√£o em profundidade, seja por meios convencionais ou pelo aprendizado implac√°vel ao longo de suas carreiras. Os engenheiros do tipo 2 normalmente permanecem na superf√≠cie, aprendendo ferramentas e tecnologias espec√≠ficas em vez de suas funda√ß√µes subjacentes, apenas adquirindo novas habilidades quando os ventos da moda t√©cnica mudam.

Atualmente, o n√∫mero de pessoas que entram na ind√∫stria est√° aumentando rapidamente, enquanto o n√∫mero de graduados em CS √© essencialmente est√°tico. Esse excesso de oferta de engenheiros do Tipo 2 est√° come√ßando a reduzir suas oportunidades de emprego e a mant√™-los fora do trabalho mais gratificante do setor. N√£o importa se voc√™ est√° se esfor√ßando para se tornar um engenheiro do Tipo 1 ou simplesmente procurando mais seguran√ßa no trabalho, aprender ci√™ncia da computa√ß√£o √© o √∫nico caminho confi√°vel.

## Guias de T√≥picos

### Programa√ß√£o

A maioria dos programas de p√≥s-gradua√ß√£o come√ßa com uma ‚Äúintrodu√ß√£o‚Äù √† programa√ß√£o de computadores. As melhores vers√µes desses cursos atendem n√£o apenas aos novatos, mas tamb√©m √†queles que perderam conceitos e modelos de programa√ß√£o ben√©ficos enquanto aprendiam a programar.

Nossa recomenda√ß√£o padr√£o para este conte√∫do √© o classico *Structure and Interpretation of Computer Programs*, que est√° dispon√≠vel on-line gratuitamente [como livro](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html) e como um conjunto de [palestras em v√≠deo do MIT](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/). Embora essas palestras sejam √≥timas, nossa sugest√£o de v√≠deo √© na verdade as palestras do [SICP do Brian Harvey](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) (para o curso 61A em Berkeley). Estes s√£o mais refinados e mais direcionados a novos alunos do que as palestras do MIT.

Recomendamos trabalhar pelo menos nos tr√™s primeiros cap√≠tulos do SICP e fazer os exerc√≠cios. Para uma pr√°tica adicional, trabalhe com um conjunto de pequenos problemas de programa√ß√£o, como os do [exercism](http://exercism.io/).

Para aqueles que acham o SICP muito desafiador, recomendamos o [How to Design Programs](https://htdp.org/). Para aqueles que acham que √© muito f√°cil, recomendamos [Concepts, Techniques, and Models of Computer Programming](https://smile.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695/).

### Arquitetura de Computadores

### Algoritmos e Estruturas de Dados

### Matem√°tica para Ci√™ncia da Computa√ß√£o

### Sistemas operacionais

### Redes de Computadores

### Bancos de dados

### Idiomas e Compiladores

### Sistemas distribu√≠dos


## Perguntas frequentes

### E quanto a IA / gr√°ficos / pet-topic-X?

Tentamos limitar nossa lista a t√≥picos de ci√™ncia da computa√ß√£o que sentimos que todo engenheiro de software praticante deve saber, independentemente de especialidade ou setor. Com essa base, voc√™ estar√° em uma posi√ß√£o muito melhor para pegar livros ou documentos e aprender os principais conceitos sem muita orienta√ß√£o. Aqui est√£o os nossos pontos de partida sugeridos para algumas ‚Äúeletivas‚Äù comuns:

- Para intelig√™ncia artificial: fa√ßa [Berkeley‚Äôs intro to AI course](http://ai.berkeley.edu/) assistindo aos v√≠deos e completando os excelentes projetos de Pacman. Como livro did√°tico, use *Russell and Norvig‚Äôs Artificial Intelligence: A Modern Approach.*.
- Para aprendizado de m√°quina: fa√ßa o curso no Coursera do Andrew Ng. Seja paciente e certifique-se de entender os fundamentos antes de partir para novos t√≥picos brilhantes, como o *deep learning*.
- Para computa√ß√£o gr√°fica: trabalhe com o material [CS 184 da Berkeley](http://inst.eecs.berkeley.edu/~cs184/fa12/onlinelectures.html) e use [Computer Graphics: Principles and Practice](https://www.amazon.com/Computer-Graphics-Principles-Practice-3rd/dp/0321399528) como um livro did√°tico.

### Qu√£o rigoroso √© o sequenciamento sugerido?

Realisticamente, todos esses t√≥picos t√™m uma quantidade significativa de sobreposi√ß√£o e referem-se uns aos outros ciclicamente. Tomemos por exemplo a rela√ß√£o entre matem√°tica discreta e algoritmos: aprender matem√°tica primeiro ajudaria voc√™ a analisar e compreender seus algoritmos em maior profundidade, mas primeiro os algoritmos de aprendizagem forneceriam maior motiva√ß√£o e contexto para a matem√°tica discreta. Idealmente, voc√™ revisitaria esses dois t√≥picos v√°rias vezes ao longo de sua carreira.

Como tal, o nosso sequenciamento sugerido est√° principalmente l√° para ajud√°-lo a apenas come√ßar... se voc√™ tem uma raz√£o convincente para preferir uma sequ√™ncia diferente, ent√£o v√° em frente. Os ‚Äúpr√©-requisitos‚Äù mais significativos em nossa opini√£o s√£o: arquitetura de computadores antes de sistemas operacionais ou bancos de dados, e redes e sistemas operacionais antes dos sistemas distribu√≠dos.

### Quem √© o p√∫blico-alvo deste guia?

Temos em mente que voc√™ √© um engenheiro de software autodidata, graduado em um curso t√©cnico ou estudante do ensino m√©dio precoce, ou um estudante universit√°rio procurando complementar sua educa√ß√£o formal com algum estudo aut√¥nomo. A quest√£o de quando embarcar nessa jornada √© inteiramente pessoal, mas a maioria das pessoas tende a se beneficiar de alguma experi√™ncia profissional antes de mergulhar muito na teoria da *Ci√™ncia da Computa√ß√£o*. Por exemplo, percebemos que os alunos adoram aprender sobre sistemas de banco de dados se j√° trabalharam com bancos de dados profissionalmente ou sobre redes de computadores, se trabalharam em um ou dois projetos da web.

### Como isso se compara aos curr√≠culos do Open Source Society ou freeCodeCamp?

O [guia OSS](https://github.com/open-source-society/computer-science) tem muitos assuntos, sugere recursos inferiores para muitos deles e n√£o fornece nenhum racioc√≠nio ou orienta√ß√£o sobre por que ou quais aspectos de determinados cursos s√£o valiosos. N√≥s nos esfor√ßamos para limitar nossa lista de cursos √†queles que voc√™ realmente deve saber como engenheiro de software, independentemente de sua especialidade, e para ajud√°-lo a entender por que cada curso est√° inclu√≠do.

O freeCodeCamp √© focado principalmente em programa√ß√£o, n√£o em ci√™ncia da computa√ß√£o. Por que voc√™ pode querer aprender ci√™ncia da computa√ß√£o, veja acima.

### E a linguagem X?

Aprender uma linguagem de programa√ß√£o espec√≠fica √© um plano totalmente diferente de aprender sobre uma √°rea da ci√™ncia da computa√ß√£o - aprender uma l√≠ngua √© muito mais f√°cil e tem muito menos valor. Se voc√™ j√° conhece algumas linguagens, sugerimos que voc√™ simplesmente siga nosso guia e ajuste a aquisi√ß√£o de linguagens nas lacunas ou deixe-o para depois. 

Se voc√™ aprendeu a programar direito (como atrav√©s da Estrutura e Interpreta√ß√£o de Programas de Computador ), e especialmente se voc√™ aprendeu compiladores, voc√™ deve levar pouco mais que um fim de semana para aprender os fundamentos de uma nova linguagem.

### E sobre a tecnologia da moda X?

Nenhuma tecnologia √© importante o suficiente para que aprender a us√°-la seja uma parte fundamental de sua educa√ß√£o. Por outro lado, √© √≥timo que voc√™ esteja animado para aprender sobre isso. O truque √© trabalhar de tr√°s para frente a partir da tecnologia espec√≠fica para o campo ou conceito subjacente, e aprender isso em profundidade antes de ver como sua tecnologia moderna se encaixa no quadro maior.

### Como posso obter livros did√°ticos de forma barata?

Muitos dos livros did√°ticos que sugerimos est√£o dispon√≠veis gratuitamente on-line, gra√ßas √† generosidade de seus autores. Para aqueles que n√£o s√£o, sugerimos comprar c√≥pias usadas de edi√ß√µes antigas. Como regra geral, se houver mais de duas edi√ß√µes de um livro, √© bem prov√°vel que uma edi√ß√£o mais antiga seja perfeitamente adequada. √â certamente improv√°vel que a vers√£o mais recente seja 10x melhor que uma vers√£o mais antiga, mesmo que seja essa a diferen√ßa de pre√ßo!

Qaundo houver disponibilidade de tradu√ß√£o de algum livro, vamos disponibilizar aqui neste guia. Muito provavelmente referenciado com a flag do Brasil &#x1f1e7;&#x1f1f7;

### Quem faz isso?

Este guia foi escrito originalmente em ingl√™s por [Ozan Onay](https://twitter.com/oznova_) e [Myles Byrne](https://twitter.com/quackingduck), instrutores da [Bradfield School of Computer Science](https://bradfieldcs.com/), em San Francisco. Baseia-se na experi√™ncia deles no ensino de ci√™ncia da computa√ß√£o b√°sica para centenas de engenheiros e graduados em treinamento autodidata.

Atualmente a tradu√ß√£o desse projeto foi inciada por [@rafaelvieiras](https://github.com/rafaelvieiras) e n√£o se limita a uma tradu√ß√£o fiel, e sim a se basear no projeto para auxiliar brasileiros autodidata no estudo da ci√™ncia da computa√ß√£o.

A vers√£o usada como base desse material est√° em [https://teachyourselfcs.com](https://teachyourselfcs.com)
